<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>plant_selector: clustering_tests Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">plant_selector
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">clustering_tests Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Finds the centroids of weeds from provided point cloud selection.  
<a href="namespaceclustering__tests.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4ea033d1d4005c8bdedbed195adbef95"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a4ea033d1d4005c8bdedbed195adbef95">array_to_pc</a> (points)</td></tr>
<tr class="memdesc:a4ea033d1d4005c8bdedbed195adbef95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take in array of points and format it into an open3d point cloud.  <a href="namespaceclustering__tests.html#a4ea033d1d4005c8bdedbed195adbef95">More...</a><br /></td></tr>
<tr class="separator:a4ea033d1d4005c8bdedbed195adbef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc55df03eec2af5e35038957f110b701"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#afc55df03eec2af5e35038957f110b701">assemble_weeds_from_label</a> (leaves, best_S)</td></tr>
<tr class="memdesc:afc55df03eec2af5e35038957f110b701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembles dictionary of point clouds representing weeds given labels from bestS for each leaf.  <a href="namespaceclustering__tests.html#afc55df03eec2af5e35038957f110b701">More...</a><br /></td></tr>
<tr class="separator:afc55df03eec2af5e35038957f110b701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453852ec55599d14e1d32337bfe476a3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a453852ec55599d14e1d32337bfe476a3">brute_force_optimize</a> (E, leaves, max_weeds=5)</td></tr>
<tr class="memdesc:a453852ec55599d14e1d32337bfe476a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brute force optimization of cost functions to find best assignment S of leaves to weeds.  <a href="namespaceclustering__tests.html#a453852ec55599d14e1d32337bfe476a3">More...</a><br /></td></tr>
<tr class="separator:a453852ec55599d14e1d32337bfe476a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280dd86c75832fb82b62e19e01b05e25"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a280dd86c75832fb82b62e19e01b05e25">calculate_centroids</a> (segments)</td></tr>
<tr class="memdesc:a280dd86c75832fb82b62e19e01b05e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the centroid of each segment by avg position.  <a href="namespaceclustering__tests.html#a280dd86c75832fb82b62e19e01b05e25">More...</a><br /></td></tr>
<tr class="separator:a280dd86c75832fb82b62e19e01b05e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c1587453c6d39578470240c4e894e7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a46c1587453c6d39578470240c4e894e7">calculate_epsilon</a> (pcd_array)</td></tr>
<tr class="memdesc:a46c1587453c6d39578470240c4e894e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses method described here: <a href="https://towardsdatascience.com/machine-learning-clustering-dbscan-determine-the-optimal-value-for-epsilon-eps-python-example-3100091cfbc">https://towardsdatascience.com/machine-learning-clustering-dbscan-determine-the-optimal-value-for-epsilon-eps-python-example-3100091cfbc</a> and kneed package to find the ideal epsilon for our data Currently out of use because "ideal" epsilon does not neccisarily produce correct weeds.  <a href="namespaceclustering__tests.html#a46c1587453c6d39578470240c4e894e7">More...</a><br /></td></tr>
<tr class="separator:a46c1587453c6d39578470240c4e894e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70f1346c903d51a4f22b3f6e34f4e26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#ad70f1346c903d51a4f22b3f6e34f4e26">calculate_normal</a> (dirt)</td></tr>
<tr class="memdesc:ad70f1346c903d51a4f22b3f6e34f4e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds normal from dirt point cloud.  <a href="namespaceclustering__tests.html#ad70f1346c903d51a4f22b3f6e34f4e26">More...</a><br /></td></tr>
<tr class="separator:ad70f1346c903d51a4f22b3f6e34f4e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b6560df5dde5df87b39ee99e765526"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#ab6b6560df5dde5df87b39ee99e765526">DBSCAN_calculate_pose</a> (points, algorithm='npc', weights=[0, 100, 100, 0, 100, 0], return_multiple_grasps=False)</td></tr>
<tr class="memdesc:ab6b6560df5dde5df87b39ee99e765526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses DBSCAN to cluster weeds and calculate pose.  <a href="namespaceclustering__tests.html#ab6b6560df5dde5df87b39ee99e765526">More...</a><br /></td></tr>
<tr class="separator:ab6b6560df5dde5df87b39ee99e765526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ef85a6b215e9df9ef3cd6464f68af3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a05ef85a6b215e9df9ef3cd6464f68af3">distance_cost</a> (E, leaves, S)</td></tr>
<tr class="memdesc:a05ef85a6b215e9df9ef3cd6464f68af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value of the distance cost function for a given solution.  <a href="namespaceclustering__tests.html#a05ef85a6b215e9df9ef3cd6464f68af3">More...</a><br /></td></tr>
<tr class="separator:a05ef85a6b215e9df9ef3cd6464f68af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66e06167189a13c440cef7fd826e0b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#af66e06167189a13c440cef7fd826e0b7">find_combinations</a> (num_edges, max_weeds, allow_singles=True)</td></tr>
<tr class="memdesc:af66e06167189a13c440cef7fd826e0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use more_itertools to return a list of possible solutions, S.  <a href="namespaceclustering__tests.html#af66e06167189a13c440cef7fd826e0b7">More...</a><br /></td></tr>
<tr class="separator:af66e06167189a13c440cef7fd826e0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bced676eb6e53353313781958e4ebd6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a8bced676eb6e53353313781958e4ebd6">float_to_rgb</a> (float_rgb)</td></tr>
<tr class="memdesc:a8bced676eb6e53353313781958e4ebd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a packed float RGB format to an RGB list.  <a href="namespaceclustering__tests.html#a8bced676eb6e53353313781958e4ebd6">More...</a><br /></td></tr>
<tr class="separator:a8bced676eb6e53353313781958e4ebd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4a8e52e50441a0ab30147be37540c3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a1c4a8e52e50441a0ab30147be37540c3">FRG_calculate_pose</a> (points, algorithm='npc', weights=[0, 100, 100, 0, 100, 0], proximity_thresh=0.05, return_multiple_grasps=False)</td></tr>
<tr class="memdesc:a1c4a8e52e50441a0ab30147be37540c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses Facet Region Growing method and PCA to return the pose for the gripper.  <a href="namespaceclustering__tests.html#a1c4a8e52e50441a0ab30147be37540c3">More...</a><br /></td></tr>
<tr class="separator:a1c4a8e52e50441a0ab30147be37540c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10abe63328b91fe8acc812741ac9351f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a10abe63328b91fe8acc812741ac9351f">genetic_fitness_function</a> (S_bits, E, leaves)</td></tr>
<tr class="memdesc:a10abe63328b91fe8acc812741ac9351f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The least squares cost function but formatted for use with the genetic algorithm.  <a href="namespaceclustering__tests.html#a10abe63328b91fe8acc812741ac9351f">More...</a><br /></td></tr>
<tr class="separator:a10abe63328b91fe8acc812741ac9351f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d2f0c8abc2e055fcdc507bde0aebef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#af8d2f0c8abc2e055fcdc507bde0aebef">initial_segmentation</a> (points, algorithm='npc', weights=[0, 100, 100, 0, 100, 0])</td></tr>
<tr class="memdesc:af8d2f0c8abc2e055fcdc507bde0aebef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does initial segmentation --&gt; Uses specified algorithm to seperate weeds from dirt.  <a href="namespaceclustering__tests.html#af8d2f0c8abc2e055fcdc507bde0aebef">More...</a><br /></td></tr>
<tr class="separator:af8d2f0c8abc2e055fcdc507bde0aebef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1fc3ec26528c2204fcaa36f8e023d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#abe1fc3ec26528c2204fcaa36f8e023d2">kmeans_from_scratch</a> (X, k, weights=[1, 1, 1, 1, 1, 1], redmean=False)</td></tr>
<tr class="memdesc:abe1fc3ec26528c2204fcaa36f8e023d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements kmeans from scratch Mostly stolen from <a href="https://medium.com/nerd-for-tech/k-means-python-implementation-from-scratch-8400f30b8e5c">https://medium.com/nerd-for-tech/k-means-python-implementation-from-scratch-8400f30b8e5c</a>.  <a href="namespaceclustering__tests.html#abe1fc3ec26528c2204fcaa36f8e023d2">More...</a><br /></td></tr>
<tr class="separator:abe1fc3ec26528c2204fcaa36f8e023d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a30ab4a4770e18cf22eb0338592835"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a53a30ab4a4770e18cf22eb0338592835">labels_to_dict</a> (pcd, labels)</td></tr>
<tr class="memdesc:a53a30ab4a4770e18cf22eb0338592835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seperats pcd into dict of clusters based on labels.  <a href="namespaceclustering__tests.html#a53a30ab4a4770e18cf22eb0338592835">More...</a><br /></td></tr>
<tr class="separator:a53a30ab4a4770e18cf22eb0338592835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0ff0a178b17ba6845d213dee50df4f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a7b0ff0a178b17ba6845d213dee50df4f">LstSqrs_cost</a> (S, E, leaves, return_cents=False, default_res=3.5, default_dist=0.07)</td></tr>
<tr class="memdesc:a7b0ff0a178b17ba6845d213dee50df4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses least squares to find the centroids of plants given their leaf assignments.  <a href="namespaceclustering__tests.html#a7b0ff0a178b17ba6845d213dee50df4f">More...</a><br /></td></tr>
<tr class="separator:a7b0ff0a178b17ba6845d213dee50df4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03a7abe78a14d571ca8beabd384da3c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#aa03a7abe78a14d571ca8beabd384da3c">reduce_S</a> (S)</td></tr>
<tr class="memdesc:aa03a7abe78a14d571ca8beabd384da3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If S contains non-consecutive numbers, we can fix that.  <a href="namespaceclustering__tests.html#aa03a7abe78a14d571ca8beabd384da3c">More...</a><br /></td></tr>
<tr class="separator:aa03a7abe78a14d571ca8beabd384da3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5cfd66d1f61ccf9738553d2f3e5af1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a6f5cfd66d1f61ccf9738553d2f3e5af1">remove_false_positives</a> (centroids, weeds_array)</td></tr>
<tr class="memdesc:a6f5cfd66d1f61ccf9738553d2f3e5af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete centroid guesses that are not near any weed points.  <a href="namespaceclustering__tests.html#a6f5cfd66d1f61ccf9738553d2f3e5af1">More...</a><br /></td></tr>
<tr class="separator:a6f5cfd66d1f61ccf9738553d2f3e5af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117fe62ffe51ff52c1d77c8e02881d26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a117fe62ffe51ff52c1d77c8e02881d26">separate_by_height</a> (segments, height_threshold=0.001)</td></tr>
<tr class="memdesc:a117fe62ffe51ff52c1d77c8e02881d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seperates dirt point cloud and weed point clouds by avg height.  <a href="namespaceclustering__tests.html#a117fe62ffe51ff52c1d77c8e02881d26">More...</a><br /></td></tr>
<tr class="separator:a117fe62ffe51ff52c1d77c8e02881d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bc271d1adef52764a15cc65d0e5d28"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#aa3bc271d1adef52764a15cc65d0e5d28">separate_by_size</a> (segments, using_npc=False)</td></tr>
<tr class="memdesc:aa3bc271d1adef52764a15cc65d0e5d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seperates dirt point cloud and weed point clouds by number of pts.  <a href="namespaceclustering__tests.html#aa3bc271d1adef52764a15cc65d0e5d28">More...</a><br /></td></tr>
<tr class="separator:aa3bc271d1adef52764a15cc65d0e5d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e4c1a10394ff38deccdb22eed6cf71"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclustering__tests.html#a26e4c1a10394ff38deccdb22eed6cf71">solution_to_plants</a> (E, leaves, S)</td></tr>
<tr class="memdesc:a26e4c1a10394ff38deccdb22eed6cf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the solution S to create a dictionary of edges and a dictionary of points.  <a href="namespaceclustering__tests.html#a26e4c1a10394ff38deccdb22eed6cf71">More...</a><br /></td></tr>
<tr class="separator:a26e4c1a10394ff38deccdb22eed6cf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Finds the centroids of weeds from provided point cloud selection. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4ea033d1d4005c8bdedbed195adbef95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea033d1d4005c8bdedbed195adbef95">&#9670;&nbsp;</a></span>array_to_pc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.array_to_pc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take in array of points and format it into an open3d point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>list of points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>open3d pc, array of points, array of colors </dd></dl>

</div>
</div>
<a id="afc55df03eec2af5e35038957f110b701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc55df03eec2af5e35038957f110b701">&#9670;&nbsp;</a></span>assemble_weeds_from_label()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.assemble_weeds_from_label </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>best_S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assembles dictionary of point clouds representing weeds given labels from bestS for each leaf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaves</td><td>a list of numpy arrays. each numpy array is a leaf (usually from facet region growing) </td></tr>
    <tr><td class="paramname">best_S</td><td>a list of integers. each element is the weed label for one leaf in leaves</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dictionary of point clouds where each point cloud is a weed </dd></dl>

</div>
</div>
<a id="a453852ec55599d14e1d32337bfe476a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453852ec55599d14e1d32337bfe476a3">&#9670;&nbsp;</a></span>brute_force_optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.brute_force_optimize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_weeds</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Brute force optimization of cost functions to find best assignment S of leaves to weeds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>An Nx6 matrix where each row corresponds to a line (as defined by two 3d points) representing a leaf </td></tr>
    <tr><td class="paramname">leaves</td><td>a list where each element is a numpy array containing xyz points for each leaf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>best assignments S, cost for that assignment, centroid locations from least squares for S </dd></dl>

</div>
</div>
<a id="a280dd86c75832fb82b62e19e01b05e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280dd86c75832fb82b62e19e01b05e25">&#9670;&nbsp;</a></span>calculate_centroids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.calculate_centroids </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the centroid of each segment by avg position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segments</td><td>dict containing point cloud segments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of centroids corresponding to each segment </dd></dl>

</div>
</div>
<a id="a46c1587453c6d39578470240c4e894e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c1587453c6d39578470240c4e894e7">&#9670;&nbsp;</a></span>calculate_epsilon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.calculate_epsilon </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pcd_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses method described here: <a href="https://towardsdatascience.com/machine-learning-clustering-dbscan-determine-the-optimal-value-for-epsilon-eps-python-example-3100091cfbc">https://towardsdatascience.com/machine-learning-clustering-dbscan-determine-the-optimal-value-for-epsilon-eps-python-example-3100091cfbc</a> and kneed package to find the ideal epsilon for our data Currently out of use because "ideal" epsilon does not neccisarily produce correct weeds. </p>
<p>Hand tuned value is 0.004.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcd_array</td><td>numpy array containing x,y, and z points from pt cloud</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ideal epsilon to use for DBSCAN based on data </dd></dl>

</div>
</div>
<a id="ad70f1346c903d51a4f22b3f6e34f4e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70f1346c903d51a4f22b3f6e34f4e26">&#9670;&nbsp;</a></span>calculate_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.calculate_normal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dirt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds normal from dirt point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirt</td><td>the open3d point cloud containing dirt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>normal of dirt </dd></dl>

</div>
</div>
<a id="ab6b6560df5dde5df87b39ee99e765526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b6560df5dde5df87b39ee99e765526">&#9670;&nbsp;</a></span>DBSCAN_calculate_pose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.DBSCAN_calculate_pose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code>'npc'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>[0,100,100,0,100,0]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_multiple_grasps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses DBSCAN to cluster weeds and calculate pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>a list of points from the point cloud from the selection </td></tr>
    <tr><td class="paramname">algorithm</td><td>string containing algorithm choice. options include 'kmeans-optimized', 'kmeans-redmean', 'kmeans-euclidean', 'bi-kmeans', 'spectral', 'ward', 'npc' </td></tr>
    <tr><td class="paramname">weights</td><td>a list containing 6 weights for weighted kmeans implementation. weights must be &gt;= 0 </td></tr>
    <tr><td class="paramname">return_multiple_grasps</td><td>Boolean indicating whether or not to return multiple grasps for selections of multiple weeds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of weed centroids, normal associated with dirt </dd></dl>

</div>
</div>
<a id="a05ef85a6b215e9df9ef3cd6464f68af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ef85a6b215e9df9ef3cd6464f68af3">&#9670;&nbsp;</a></span>distance_cost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.distance_cost </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the value of the distance cost function for a given solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>a Hx6 numpy array where each row is a set of edges representing a facet. The first 3 values are coords of endpoint 1 and the last 3 values are coords of endpoint 2 </td></tr>
    <tr><td class="paramname">leaves</td><td>a list of leaves. Each leaf is an Gx3 numpy array where each row is a point in the leaf. </td></tr>
    <tr><td class="paramname">S</td><td>a list of integers representing weed assignments (S is similar to the labels output of DBSCAN)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a float that decreases as the leaves in a weed assignment get closer together </dd></dl>

</div>
</div>
<a id="af66e06167189a13c440cef7fd826e0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66e06167189a13c440cef7fd826e0b7">&#9670;&nbsp;</a></span>find_combinations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.find_combinations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_weeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_singles</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use more_itertools to return a list of possible solutions, S. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_edges</td><td>the number of edges (or facets) we are trying to find a solution for. This dictates the length of S </td></tr>
    <tr><td class="paramname">max_weeds</td><td>the maximum number of weeds we are assuming exist in the selection. This dictates the highest possible value in S </td></tr>
    <tr><td class="paramname">allow_singles</td><td>optional, boolean, True if you want to allow S to allow leaves to be assigned alone to their own weed, False otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a dictionary of edges, a dictionary of points </dd></dl>

</div>
</div>
<a id="a8bced676eb6e53353313781958e4ebd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bced676eb6e53353313781958e4ebd6">&#9670;&nbsp;</a></span>float_to_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.float_to_rgb </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>float_rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a packed float RGB format to an RGB list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float_rgb</td><td>RGB value packed as a float</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>color (list): 3-element list of integers [0-255,0-255,0-255] </dd></dl>

</div>
</div>
<a id="a1c4a8e52e50441a0ab30147be37540c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4a8e52e50441a0ab30147be37540c3">&#9670;&nbsp;</a></span>FRG_calculate_pose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.FRG_calculate_pose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code>'npc'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>[0,100,100,0,100,0]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proximity_thresh</em> = <code>0.05</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_multiple_grasps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses Facet Region Growing method and PCA to return the pose for the gripper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>a list of points from the point cloud from the selection </td></tr>
    <tr><td class="paramname">algorithm</td><td>string containing algorithm choice. options include 'kmeans-optimized', 'kmeans-redmean', 'kmeans-euclidean', 'bi-kmeans', 'spectral', 'ward', 'npc </td></tr>
    <tr><td class="paramname">weights</td><td>a list containing 6 weights for weighted kmeans implementation. weights must be &gt;= 0 </td></tr>
    <tr><td class="paramname">return_multiple_grasps</td><td>Boolean indicating whether or not to return multiple grasps for selections of multiple weeds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of weed centroids, normal associated with dirt </dd></dl>

</div>
</div>
<a id="a10abe63328b91fe8acc812741ac9351f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10abe63328b91fe8acc812741ac9351f">&#9670;&nbsp;</a></span>genetic_fitness_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.genetic_fitness_function </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaves</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The least squares cost function but formatted for use with the genetic algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S_bits</td><td>a list of bits where each set of 3 is binary for a single integer value between 0 and 7 </td></tr>
    <tr><td class="paramname">E</td><td>An Nx6 matrix where each row corresponds to a line (as defined by two 3d points) representing a leaf </td></tr>
    <tr><td class="paramname">leaves</td><td>a list where each element is a numpy array containing xyz points for each leaf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>least squares mean distance cost (goes up as solution becomes more correct, as is required by the genetic algorithm) </dd></dl>

</div>
</div>
<a id="af8d2f0c8abc2e055fcdc507bde0aebef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d2f0c8abc2e055fcdc507bde0aebef">&#9670;&nbsp;</a></span>initial_segmentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.initial_segmentation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code>'npc'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>[0,100,100,0,100,0]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does initial segmentation --&gt; Uses specified algorithm to seperate weeds from dirt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>a list of points from the point cloud from the selection </td></tr>
    <tr><td class="paramname">algorithm</td><td>optional, string containing algorithm choice. options include 'kmeans-optimized', 'kmeans-redmean', 'kmeans-euclidean', 'bi-kmeans', 'spectral', 'ward', 'npc' </td></tr>
    <tr><td class="paramname">weights</td><td>optional, a list containing 6 weights for weighted kmeans implementation. weights must be &gt;= 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point cloud of weeds, point cloud of dirt </dd></dl>

</div>
</div>
<a id="abe1fc3ec26528c2204fcaa36f8e023d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1fc3ec26528c2204fcaa36f8e023d2">&#9670;&nbsp;</a></span>kmeans_from_scratch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.kmeans_from_scratch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>[1,&#160;1,&#160;1,&#160;1,&#160;1,&#160;1]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>redmean</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements kmeans from scratch Mostly stolen from <a href="https://medium.com/nerd-for-tech/k-means-python-implementation-from-scratch-8400f30b8e5c">https://medium.com/nerd-for-tech/k-means-python-implementation-from-scratch-8400f30b8e5c</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>a list of points from the point cloud from the selection </td></tr>
    <tr><td class="paramname">k</td><td>desired number of clusters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>labels and their centroids </dd></dl>

</div>
</div>
<a id="a53a30ab4a4770e18cf22eb0338592835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a30ab4a4770e18cf22eb0338592835">&#9670;&nbsp;</a></span>labels_to_dict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.labels_to_dict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seperats pcd into dict of clusters based on labels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcd</td><td>the open3d point cloud in question </td></tr>
    <tr><td class="paramname">labels</td><td>list of labels (eg from dbscan or kmeans, list of integers)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dictionary containing pointclouds by cluster </dd></dl>

</div>
</div>
<a id="a7b0ff0a178b17ba6845d213dee50df4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0ff0a178b17ba6845d213dee50df4f">&#9670;&nbsp;</a></span>LstSqrs_cost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.LstSqrs_cost </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_cents</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default_res</em> = <code>3.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default_dist</em> = <code>0.07</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses least squares to find the centroids of plants given their leaf assignments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>a list of integer labels corresponding to each leaf </td></tr>
    <tr><td class="paramname">E</td><td>An Nx6 matrix where each row corresponds to a line (as defined by two 3d points) representing a leaf </td></tr>
    <tr><td class="paramname">leaves</td><td>a list where each element is a numpy array containing xyz points for each leaf </td></tr>
    <tr><td class="paramname">default_res</td><td>optional, a float assigning a default least squares residual in the event that least squares cannot find one (usually for cases where there is a single leaf alone in an assignment) </td></tr>
    <tr><td class="paramname">default_dist</td><td>optional, a float assigning a default least squares mean distance in the event that least squares cannot find one (usually for cases where there is a single leaf alone in an assignment)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of the residuals from least squares, sum of distances to mean locations, list of centroids for each weed </dd></dl>

</div>
</div>
<a id="aa03a7abe78a14d571ca8beabd384da3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03a7abe78a14d571ca8beabd384da3c">&#9670;&nbsp;</a></span>reduce_S()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.reduce_S </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If S contains non-consecutive numbers, we can fix that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>a list of integers representing weed assignments (S is similar to the labels output of DBSCAN)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a fixed version of S </dd></dl>

</div>
</div>
<a id="a6f5cfd66d1f61ccf9738553d2f3e5af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5cfd66d1f61ccf9738553d2f3e5af1">&#9670;&nbsp;</a></span>remove_false_positives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.remove_false_positives </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weeds_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete centroid guesses that are not near any weed points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">centroids</td><td>a numpy array where each row is a centroid guess </td></tr>
    <tr><td class="paramname">weeds_array</td><td>a numpy array where each row is a point in the point cloud of all weeds (ie. excluding dirt and rocks)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a numpy array containing only centroids near weeds </dd></dl>

</div>
</div>
<a id="a117fe62ffe51ff52c1d77c8e02881d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117fe62ffe51ff52c1d77c8e02881d26">&#9670;&nbsp;</a></span>separate_by_height()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.separate_by_height </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>height_threshold</em> = <code>0.001</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seperates dirt point cloud and weed point clouds by avg height. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segments</td><td>dict containing all segments of point cloud </td></tr>
    <tr><td class="paramname">height_threshold</td><td>float</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weeds, dirt pointclouds containing weeds and dirt respecively </dd></dl>

</div>
</div>
<a id="aa3bc271d1adef52764a15cc65d0e5d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bc271d1adef52764a15cc65d0e5d28">&#9670;&nbsp;</a></span>separate_by_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.separate_by_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>using_npc</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seperates dirt point cloud and weed point clouds by number of pts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segments</td><td>dict containing all segments of point cloud</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weeds, dirt: pointclouds containing weeds and dirt respecively </dd></dl>

</div>
</div>
<a id="a26e4c1a10394ff38deccdb22eed6cf71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e4c1a10394ff38deccdb22eed6cf71">&#9670;&nbsp;</a></span>solution_to_plants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def clustering_tests.solution_to_plants </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the solution S to create a dictionary of edges and a dictionary of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>a Hx6 numpy array where each row is a set of edges representing a facet. The first 3 values are coords of endpoint 1 and the last 3 values are coords of endpoint 2 </td></tr>
    <tr><td class="paramname">leaves</td><td>a list of leaves. Each leaf is an Gx3 numpy array where each row is a point in the leaf. </td></tr>
    <tr><td class="paramname">S</td><td>a list of integers representing weed assignments (S is similar to the labels output of DBSCAN)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a dictionary of edges, a dictionary of points </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
