<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>plant_selector: find_centroids Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">plant_selector
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">find_centroids Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Finds the centroids of weeds from provided point cloud selection.  
<a href="namespacefind__centroids.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a69b148f70ede83bbebd2e24354fff972"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a69b148f70ede83bbebd2e24354fff972">array_to_pc</a> (points)</td></tr>
<tr class="memdesc:a69b148f70ede83bbebd2e24354fff972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take in array of points and format it into an open3d point cloud.  <a href="namespacefind__centroids.html#a69b148f70ede83bbebd2e24354fff972">More...</a><br /></td></tr>
<tr class="separator:a69b148f70ede83bbebd2e24354fff972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90de2eb3f3b76c75eae34dc62b17e5d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a90de2eb3f3b76c75eae34dc62b17e5d4">assemble_weeds_from_label</a> (leaves, best_S)</td></tr>
<tr class="memdesc:a90de2eb3f3b76c75eae34dc62b17e5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembles dictionary of point clouds representing weeds given labels from bestS for each leaf.  <a href="namespacefind__centroids.html#a90de2eb3f3b76c75eae34dc62b17e5d4">More...</a><br /></td></tr>
<tr class="separator:a90de2eb3f3b76c75eae34dc62b17e5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058cd803769fddea0beb709cffab930a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a058cd803769fddea0beb709cffab930a">brute_force_optimize</a> (E, leaves, max_weeds=5)</td></tr>
<tr class="memdesc:a058cd803769fddea0beb709cffab930a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brute force optimization of cost functions to find best assignment S of leaves to weeds.  <a href="namespacefind__centroids.html#a058cd803769fddea0beb709cffab930a">More...</a><br /></td></tr>
<tr class="separator:a058cd803769fddea0beb709cffab930a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a882ae85868a196a87701e2748ce481"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a9a882ae85868a196a87701e2748ce481">calculate_centroids</a> (segments)</td></tr>
<tr class="memdesc:a9a882ae85868a196a87701e2748ce481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the centroid of each segment by avg position.  <a href="namespacefind__centroids.html#a9a882ae85868a196a87701e2748ce481">More...</a><br /></td></tr>
<tr class="separator:a9a882ae85868a196a87701e2748ce481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d68395efaac405722198ff2545c0d96"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a0d68395efaac405722198ff2545c0d96">calculate_epsilon</a> (pcd_array)</td></tr>
<tr class="memdesc:a0d68395efaac405722198ff2545c0d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses method described here: <a href="https://towardsdatascience.com/machine-learning-clustering-dbscan-determine-the-optimal-value-for-epsilon-eps-python-example-3100091cfbc">https://towardsdatascience.com/machine-learning-clustering-dbscan-determine-the-optimal-value-for-epsilon-eps-python-example-3100091cfbc</a> and kneed package to find the ideal epsilon for our data Currently out of use because "ideal" epsilon does not neccisarily produce correct weeds.  <a href="namespacefind__centroids.html#a0d68395efaac405722198ff2545c0d96">More...</a><br /></td></tr>
<tr class="separator:a0d68395efaac405722198ff2545c0d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e798e6ce2e1f904b96ab84cfaff96b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a1e798e6ce2e1f904b96ab84cfaff96b7">calculate_normal</a> (dirt)</td></tr>
<tr class="memdesc:a1e798e6ce2e1f904b96ab84cfaff96b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds normal from dirt point cloud.  <a href="namespacefind__centroids.html#a1e798e6ce2e1f904b96ab84cfaff96b7">More...</a><br /></td></tr>
<tr class="separator:a1e798e6ce2e1f904b96ab84cfaff96b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f96db15ab24f13be1aa2a5579a3b65"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a16f96db15ab24f13be1aa2a5579a3b65">color_calculate_pose</a> (points, return_multiple_grasps=False)</td></tr>
<tr class="memdesc:a16f96db15ab24f13be1aa2a5579a3b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses ratios between colors and DBSCAN to calculate the poses for weeds in the provided selection.  <a href="namespacefind__centroids.html#a16f96db15ab24f13be1aa2a5579a3b65">More...</a><br /></td></tr>
<tr class="separator:a16f96db15ab24f13be1aa2a5579a3b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc1ce41db489dbbe9d684fc88d0e5a5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a5bc1ce41db489dbbe9d684fc88d0e5a5">DBSCAN_calculate_pose</a> (points, algorithm='npc', weights=[0, 100, 100, 0, 100, 0], return_multiple_grasps=False)</td></tr>
<tr class="memdesc:a5bc1ce41db489dbbe9d684fc88d0e5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses DBSCAN to cluster weeds and calculate pose.  <a href="namespacefind__centroids.html#a5bc1ce41db489dbbe9d684fc88d0e5a5">More...</a><br /></td></tr>
<tr class="separator:a5bc1ce41db489dbbe9d684fc88d0e5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac996809e98e41b86750ce4cf29f03845"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#ac996809e98e41b86750ce4cf29f03845">distance_cost</a> (E, leaves, S)</td></tr>
<tr class="memdesc:ac996809e98e41b86750ce4cf29f03845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value of the distance cost function for a given solution.  <a href="namespacefind__centroids.html#ac996809e98e41b86750ce4cf29f03845">More...</a><br /></td></tr>
<tr class="separator:ac996809e98e41b86750ce4cf29f03845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466ad552ce38cb12d18c5360ae68218e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a466ad552ce38cb12d18c5360ae68218e">find_combinations</a> (num_edges, max_weeds, allow_singles=True)</td></tr>
<tr class="memdesc:a466ad552ce38cb12d18c5360ae68218e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use more_itertools to return a list of possible solutions, S.  <a href="namespacefind__centroids.html#a466ad552ce38cb12d18c5360ae68218e">More...</a><br /></td></tr>
<tr class="separator:a466ad552ce38cb12d18c5360ae68218e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1e6562dd01f5155ee4faac586c4b2e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a8d1e6562dd01f5155ee4faac586c4b2e">float_to_rgb</a> (float_rgb)</td></tr>
<tr class="memdesc:a8d1e6562dd01f5155ee4faac586c4b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a packed float RGB format to an RGB list.  <a href="namespacefind__centroids.html#a8d1e6562dd01f5155ee4faac586c4b2e">More...</a><br /></td></tr>
<tr class="separator:a8d1e6562dd01f5155ee4faac586c4b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f86a352a844193fbd33174406ece525"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a4f86a352a844193fbd33174406ece525">FRG_calculate_pose</a> (points, algorithm='npc', weights=[0, 100, 100, 0, 100, 0], proximity_thresh=0.05, return_multiple_grasps=False)</td></tr>
<tr class="memdesc:a4f86a352a844193fbd33174406ece525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses Facet Region Growing method and PCA to return the pose for the gripper.  <a href="namespacefind__centroids.html#a4f86a352a844193fbd33174406ece525">More...</a><br /></td></tr>
<tr class="separator:a4f86a352a844193fbd33174406ece525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5fd300b0f9a81b231a9574a056d613"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#aea5fd300b0f9a81b231a9574a056d613">genetic_fitness_function</a> (S_bits, E, leaves)</td></tr>
<tr class="memdesc:aea5fd300b0f9a81b231a9574a056d613"><td class="mdescLeft">&#160;</td><td class="mdescRight">The least squares cost function but formatted for use with the genetic algorithm.  <a href="namespacefind__centroids.html#aea5fd300b0f9a81b231a9574a056d613">More...</a><br /></td></tr>
<tr class="separator:aea5fd300b0f9a81b231a9574a056d613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea808e71d17ac65418d4dfc13f6d8b62"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#aea808e71d17ac65418d4dfc13f6d8b62">initial_segmentation</a> (points, algorithm='npc', weights=[0, 100, 100, 0, 100, 0])</td></tr>
<tr class="memdesc:aea808e71d17ac65418d4dfc13f6d8b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does initial segmentation --&gt; Uses specified algorithm to seperate weeds from dirt.  <a href="namespacefind__centroids.html#aea808e71d17ac65418d4dfc13f6d8b62">More...</a><br /></td></tr>
<tr class="separator:aea808e71d17ac65418d4dfc13f6d8b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f4e831862cd20508723ae9bc40a29b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#ae8f4e831862cd20508723ae9bc40a29b">kmeans_from_scratch</a> (X, k, weights=[1, 1, 1, 1, 1, 1], redmean=False)</td></tr>
<tr class="memdesc:ae8f4e831862cd20508723ae9bc40a29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements kmeans from scratch Mostly stolen from <a href="https://medium.com/nerd-for-tech/k-means-python-implementation-from-scratch-8400f30b8e5c">https://medium.com/nerd-for-tech/k-means-python-implementation-from-scratch-8400f30b8e5c</a>.  <a href="namespacefind__centroids.html#ae8f4e831862cd20508723ae9bc40a29b">More...</a><br /></td></tr>
<tr class="separator:ae8f4e831862cd20508723ae9bc40a29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7a58a12c61b028f55e7fef64fabdb3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#aea7a58a12c61b028f55e7fef64fabdb3">labels_to_dict</a> (pcd, labels)</td></tr>
<tr class="memdesc:aea7a58a12c61b028f55e7fef64fabdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seperats pcd into dict of clusters based on labels.  <a href="namespacefind__centroids.html#aea7a58a12c61b028f55e7fef64fabdb3">More...</a><br /></td></tr>
<tr class="separator:aea7a58a12c61b028f55e7fef64fabdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3507902e540b8fd485f1734dc8866e8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#ac3507902e540b8fd485f1734dc8866e8">LstSqrs_cost</a> (S, E, leaves, return_cents=False, default_res=3.5, default_dist=0.07)</td></tr>
<tr class="memdesc:ac3507902e540b8fd485f1734dc8866e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses least squares to find the centroids of plants given their leaf assignments.  <a href="namespacefind__centroids.html#ac3507902e540b8fd485f1734dc8866e8">More...</a><br /></td></tr>
<tr class="separator:ac3507902e540b8fd485f1734dc8866e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd07f5310508fa5454c803e06fcdc43f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#afd07f5310508fa5454c803e06fcdc43f">reduce_S</a> (S)</td></tr>
<tr class="memdesc:afd07f5310508fa5454c803e06fcdc43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If S contains non-consecutive numbers, we can fix that.  <a href="namespacefind__centroids.html#afd07f5310508fa5454c803e06fcdc43f">More...</a><br /></td></tr>
<tr class="separator:afd07f5310508fa5454c803e06fcdc43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc6a0486a2ed528fde06c03b05cacff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a9cc6a0486a2ed528fde06c03b05cacff">remove_false_positives</a> (centroids, weeds_array)</td></tr>
<tr class="memdesc:a9cc6a0486a2ed528fde06c03b05cacff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete centroid guesses that are not near any weed points.  <a href="namespacefind__centroids.html#a9cc6a0486a2ed528fde06c03b05cacff">More...</a><br /></td></tr>
<tr class="separator:a9cc6a0486a2ed528fde06c03b05cacff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae579400d0056b30df71a81c05a2e8306"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#ae579400d0056b30df71a81c05a2e8306">separate_by_height</a> (segments, height_threshold=0.001)</td></tr>
<tr class="memdesc:ae579400d0056b30df71a81c05a2e8306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seperates dirt point cloud and weed point clouds by avg height.  <a href="namespacefind__centroids.html#ae579400d0056b30df71a81c05a2e8306">More...</a><br /></td></tr>
<tr class="separator:ae579400d0056b30df71a81c05a2e8306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6406a6983f064d8b387944eb99de9be"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#af6406a6983f064d8b387944eb99de9be">separate_by_size</a> (segments, using_npc=False)</td></tr>
<tr class="memdesc:af6406a6983f064d8b387944eb99de9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seperates dirt point cloud and weed point clouds by number of pts.  <a href="namespacefind__centroids.html#af6406a6983f064d8b387944eb99de9be">More...</a><br /></td></tr>
<tr class="separator:af6406a6983f064d8b387944eb99de9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9d869e1c2a749ec0add68d3e2706e4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefind__centroids.html#a7f9d869e1c2a749ec0add68d3e2706e4">solution_to_plants</a> (E, leaves, S)</td></tr>
<tr class="memdesc:a7f9d869e1c2a749ec0add68d3e2706e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the solution S to create a dictionary of edges and a dictionary of points.  <a href="namespacefind__centroids.html#a7f9d869e1c2a749ec0add68d3e2706e4">More...</a><br /></td></tr>
<tr class="separator:a7f9d869e1c2a749ec0add68d3e2706e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Finds the centroids of weeds from provided point cloud selection. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a69b148f70ede83bbebd2e24354fff972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b148f70ede83bbebd2e24354fff972">&#9670;&nbsp;</a></span>array_to_pc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.array_to_pc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take in array of points and format it into an open3d point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>list of points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>open3d pc, array of points, array of colors </dd></dl>

</div>
</div>
<a id="a90de2eb3f3b76c75eae34dc62b17e5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90de2eb3f3b76c75eae34dc62b17e5d4">&#9670;&nbsp;</a></span>assemble_weeds_from_label()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.assemble_weeds_from_label </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>best_S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assembles dictionary of point clouds representing weeds given labels from bestS for each leaf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaves</td><td>a list of numpy arrays. each numpy array is a leaf (usually from facet region growing) </td></tr>
    <tr><td class="paramname">best_S</td><td>a list of integers. each element is the weed label for one leaf in leaves</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dictionary of point clouds where each point cloud is a weed </dd></dl>

</div>
</div>
<a id="a058cd803769fddea0beb709cffab930a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058cd803769fddea0beb709cffab930a">&#9670;&nbsp;</a></span>brute_force_optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.brute_force_optimize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_weeds</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Brute force optimization of cost functions to find best assignment S of leaves to weeds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>An Nx6 matrix where each row corresponds to a line (as defined by two 3d points) representing a leaf </td></tr>
    <tr><td class="paramname">leaves</td><td>a list where each element is a numpy array containing xyz points for each leaf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>best assignments S, cost for that assignment, centroid locations from least squares for S </dd></dl>

</div>
</div>
<a id="a9a882ae85868a196a87701e2748ce481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a882ae85868a196a87701e2748ce481">&#9670;&nbsp;</a></span>calculate_centroids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.calculate_centroids </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the centroid of each segment by avg position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segments</td><td>dict containing point cloud segments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of centroids corresponding to each segment </dd></dl>

</div>
</div>
<a id="a0d68395efaac405722198ff2545c0d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d68395efaac405722198ff2545c0d96">&#9670;&nbsp;</a></span>calculate_epsilon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.calculate_epsilon </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pcd_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses method described here: <a href="https://towardsdatascience.com/machine-learning-clustering-dbscan-determine-the-optimal-value-for-epsilon-eps-python-example-3100091cfbc">https://towardsdatascience.com/machine-learning-clustering-dbscan-determine-the-optimal-value-for-epsilon-eps-python-example-3100091cfbc</a> and kneed package to find the ideal epsilon for our data Currently out of use because "ideal" epsilon does not neccisarily produce correct weeds. </p>
<p>Hand tuned value is 0.004.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcd_array</td><td>numpy array containing x,y, and z points from pt cloud</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ideal epsilon to use for DBSCAN based on data </dd></dl>

</div>
</div>
<a id="a1e798e6ce2e1f904b96ab84cfaff96b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e798e6ce2e1f904b96ab84cfaff96b7">&#9670;&nbsp;</a></span>calculate_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.calculate_normal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dirt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds normal from dirt point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirt</td><td>the open3d point cloud containing dirt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>normal of dirt </dd></dl>

</div>
</div>
<a id="a16f96db15ab24f13be1aa2a5579a3b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f96db15ab24f13be1aa2a5579a3b65">&#9670;&nbsp;</a></span>color_calculate_pose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.color_calculate_pose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_multiple_grasps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses ratios between colors and DBSCAN to calculate the poses for weeds in the provided selection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>a list of points from the point cloud from the selection </td></tr>
    <tr><td class="paramname">return_multiple_grasps</td><td>Boolean indicating whether or not to return multiple grasps for selections of multiple weeds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of weed centroids, normal associated with dirt </dd></dl>

</div>
</div>
<a id="a5bc1ce41db489dbbe9d684fc88d0e5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc1ce41db489dbbe9d684fc88d0e5a5">&#9670;&nbsp;</a></span>DBSCAN_calculate_pose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.DBSCAN_calculate_pose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code>'npc'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>[0,100,100,0,100,0]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_multiple_grasps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses DBSCAN to cluster weeds and calculate pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>a list of points from the point cloud from the selection </td></tr>
    <tr><td class="paramname">algorithm</td><td>string containing algorithm choice. options include 'kmeans-optimized', 'kmeans-redmean', 'kmeans-euclidean', 'bi-kmeans', 'spectral', 'ward', 'npc' </td></tr>
    <tr><td class="paramname">weights</td><td>a list containing 6 weights for weighted kmeans implementation. weights must be &gt;= 0 </td></tr>
    <tr><td class="paramname">return_multiple_grasps</td><td>Boolean indicating whether or not to return multiple grasps for selections of multiple weeds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of weed centroids, normal associated with dirt </dd></dl>

</div>
</div>
<a id="ac996809e98e41b86750ce4cf29f03845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac996809e98e41b86750ce4cf29f03845">&#9670;&nbsp;</a></span>distance_cost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.distance_cost </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the value of the distance cost function for a given solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>a Hx6 numpy array where each row is a set of edges representing a facet. The first 3 values are coords of endpoint 1 and the last 3 values are coords of endpoint 2 </td></tr>
    <tr><td class="paramname">leaves</td><td>a list of leaves. Each leaf is an Gx3 numpy array where each row is a point in the leaf. </td></tr>
    <tr><td class="paramname">S</td><td>a list of integers representing weed assignments (S is similar to the labels output of DBSCAN)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a float that decreases as the leaves in a weed assignment get closer together </dd></dl>

</div>
</div>
<a id="a466ad552ce38cb12d18c5360ae68218e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466ad552ce38cb12d18c5360ae68218e">&#9670;&nbsp;</a></span>find_combinations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.find_combinations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_weeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_singles</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use more_itertools to return a list of possible solutions, S. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_edges</td><td>the number of edges (or facets) we are trying to find a solution for. This dictates the length of S </td></tr>
    <tr><td class="paramname">max_weeds</td><td>the maximum number of weeds we are assuming exist in the selection. This dictates the highest possible value in S </td></tr>
    <tr><td class="paramname">allow_singles</td><td>optional, boolean, True if you want to allow S to allow leaves to be assigned alone to their own weed, False otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a dictionary of edges, a dictionary of points </dd></dl>

</div>
</div>
<a id="a8d1e6562dd01f5155ee4faac586c4b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1e6562dd01f5155ee4faac586c4b2e">&#9670;&nbsp;</a></span>float_to_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.float_to_rgb </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>float_rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a packed float RGB format to an RGB list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float_rgb</td><td>RGB value packed as a float</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>color (list): 3-element list of integers [0-255,0-255,0-255] </dd></dl>

</div>
</div>
<a id="a4f86a352a844193fbd33174406ece525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f86a352a844193fbd33174406ece525">&#9670;&nbsp;</a></span>FRG_calculate_pose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.FRG_calculate_pose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code>'npc'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>[0,100,100,0,100,0]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proximity_thresh</em> = <code>0.05</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_multiple_grasps</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses Facet Region Growing method and PCA to return the pose for the gripper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>a list of points from the point cloud from the selection </td></tr>
    <tr><td class="paramname">algorithm</td><td>string containing algorithm choice. options include 'kmeans-optimized', 'kmeans-redmean', 'kmeans-euclidean', 'bi-kmeans', 'spectral', 'ward', 'npc </td></tr>
    <tr><td class="paramname">weights</td><td>a list containing 6 weights for weighted kmeans implementation. weights must be &gt;= 0 </td></tr>
    <tr><td class="paramname">return_multiple_grasps</td><td>Boolean indicating whether or not to return multiple grasps for selections of multiple weeds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of weed centroids, normal associated with dirt </dd></dl>

</div>
</div>
<a id="aea5fd300b0f9a81b231a9574a056d613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5fd300b0f9a81b231a9574a056d613">&#9670;&nbsp;</a></span>genetic_fitness_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.genetic_fitness_function </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaves</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The least squares cost function but formatted for use with the genetic algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S_bits</td><td>a list of bits where each set of 3 is binary for a single integer value between 0 and 7 </td></tr>
    <tr><td class="paramname">E</td><td>An Nx6 matrix where each row corresponds to a line (as defined by two 3d points) representing a leaf </td></tr>
    <tr><td class="paramname">leaves</td><td>a list where each element is a numpy array containing xyz points for each leaf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>least squares mean distance cost (goes up as solution becomes more correct, as is required by the genetic algorithm) </dd></dl>

</div>
</div>
<a id="aea808e71d17ac65418d4dfc13f6d8b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea808e71d17ac65418d4dfc13f6d8b62">&#9670;&nbsp;</a></span>initial_segmentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.initial_segmentation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code>'npc'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>[0,100,100,0,100,0]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does initial segmentation --&gt; Uses specified algorithm to seperate weeds from dirt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>a list of points from the point cloud from the selection </td></tr>
    <tr><td class="paramname">algorithm</td><td>optional, string containing algorithm choice. options include 'kmeans-optimized', 'kmeans-redmean', 'kmeans-euclidean', 'bi-kmeans', 'spectral', 'ward', 'npc' </td></tr>
    <tr><td class="paramname">weights</td><td>optional, a list containing 6 weights for weighted kmeans implementation. weights must be &gt;= 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point cloud of weeds, point cloud of dirt </dd></dl>

</div>
</div>
<a id="ae8f4e831862cd20508723ae9bc40a29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f4e831862cd20508723ae9bc40a29b">&#9670;&nbsp;</a></span>kmeans_from_scratch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.kmeans_from_scratch </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>[1,&#160;1,&#160;1,&#160;1,&#160;1,&#160;1]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>redmean</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements kmeans from scratch Mostly stolen from <a href="https://medium.com/nerd-for-tech/k-means-python-implementation-from-scratch-8400f30b8e5c">https://medium.com/nerd-for-tech/k-means-python-implementation-from-scratch-8400f30b8e5c</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>a list of points from the point cloud from the selection </td></tr>
    <tr><td class="paramname">k</td><td>desired number of clusters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>labels and their centroids </dd></dl>

</div>
</div>
<a id="aea7a58a12c61b028f55e7fef64fabdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7a58a12c61b028f55e7fef64fabdb3">&#9670;&nbsp;</a></span>labels_to_dict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.labels_to_dict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seperats pcd into dict of clusters based on labels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcd</td><td>the open3d point cloud in question </td></tr>
    <tr><td class="paramname">labels</td><td>list of labels (eg from dbscan or kmeans, list of integers)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dictionary containing pointclouds by cluster </dd></dl>

</div>
</div>
<a id="ac3507902e540b8fd485f1734dc8866e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3507902e540b8fd485f1734dc8866e8">&#9670;&nbsp;</a></span>LstSqrs_cost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.LstSqrs_cost </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_cents</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default_res</em> = <code>3.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default_dist</em> = <code>0.07</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses least squares to find the centroids of plants given their leaf assignments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>a list of integer labels corresponding to each leaf </td></tr>
    <tr><td class="paramname">E</td><td>An Nx6 matrix where each row corresponds to a line (as defined by two 3d points) representing a leaf </td></tr>
    <tr><td class="paramname">leaves</td><td>a list where each element is a numpy array containing xyz points for each leaf </td></tr>
    <tr><td class="paramname">default_res</td><td>optional, a float assigning a default least squares residual in the event that least squares cannot find one (usually for cases where there is a single leaf alone in an assignment) </td></tr>
    <tr><td class="paramname">default_dist</td><td>optional, a float assigning a default least squares mean distance in the event that least squares cannot find one (usually for cases where there is a single leaf alone in an assignment)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of the residuals from least squares, sum of distances to mean locations, list of centroids for each weed </dd></dl>

</div>
</div>
<a id="afd07f5310508fa5454c803e06fcdc43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd07f5310508fa5454c803e06fcdc43f">&#9670;&nbsp;</a></span>reduce_S()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.reduce_S </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If S contains non-consecutive numbers, we can fix that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>a list of integers representing weed assignments (S is similar to the labels output of DBSCAN)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a fixed version of S </dd></dl>

</div>
</div>
<a id="a9cc6a0486a2ed528fde06c03b05cacff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc6a0486a2ed528fde06c03b05cacff">&#9670;&nbsp;</a></span>remove_false_positives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.remove_false_positives </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>centroids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weeds_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete centroid guesses that are not near any weed points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">centroids</td><td>a numpy array where each row is a centroid guess </td></tr>
    <tr><td class="paramname">weeds_array</td><td>a numpy array where each row is a point in the point cloud of all weeds (ie. excluding dirt and rocks)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a numpy array containing only centroids near weeds </dd></dl>

</div>
</div>
<a id="ae579400d0056b30df71a81c05a2e8306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae579400d0056b30df71a81c05a2e8306">&#9670;&nbsp;</a></span>separate_by_height()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.separate_by_height </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>height_threshold</em> = <code>0.001</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seperates dirt point cloud and weed point clouds by avg height. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segments</td><td>dict containing all segments of point cloud </td></tr>
    <tr><td class="paramname">height_threshold</td><td>float</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weeds, dirt pointclouds containing weeds and dirt respecively </dd></dl>

</div>
</div>
<a id="af6406a6983f064d8b387944eb99de9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6406a6983f064d8b387944eb99de9be">&#9670;&nbsp;</a></span>separate_by_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.separate_by_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>using_npc</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seperates dirt point cloud and weed point clouds by number of pts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segments</td><td>dict containing all segments of point cloud</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weeds, dirt: pointclouds containing weeds and dirt respecively </dd></dl>

</div>
</div>
<a id="a7f9d869e1c2a749ec0add68d3e2706e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9d869e1c2a749ec0add68d3e2706e4">&#9670;&nbsp;</a></span>solution_to_plants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_centroids.solution_to_plants </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the solution S to create a dictionary of edges and a dictionary of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>a Hx6 numpy array where each row is a set of edges representing a facet. The first 3 values are coords of endpoint 1 and the last 3 values are coords of endpoint 2 </td></tr>
    <tr><td class="paramname">leaves</td><td>a list of leaves. Each leaf is an Gx3 numpy array where each row is a point in the leaf. </td></tr>
    <tr><td class="paramname">S</td><td>a list of integers representing weed assignments (S is similar to the labels output of DBSCAN)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a dictionary of edges, a dictionary of points </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
